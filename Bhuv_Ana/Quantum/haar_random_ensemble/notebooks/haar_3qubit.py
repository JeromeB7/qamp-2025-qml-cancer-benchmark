# -*- coding: utf-8 -*-
"""haar_3qubit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vwJ4MQSaKX9BGEc9olTU_7c1PIViE77r
"""

!pip install qiskit qiskit-aer

import numpy as np
import pandas as pd

from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, f1_score

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector, state_fidelity

data = load_breast_cancer()

X = data.data
y = data.target

feature_names = data.feature_names
target_names = data.target_names

print(X.shape, y.shape)

X_train, X_test, y_train, y_test = train_test_split(
    X,
    y,
    test_size=0.2,
    random_state=42,
    stratify=y
)

scaler = StandardScaler()

X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

n_qubits = 2

pca = PCA(n_components=n_qubits, random_state=42)

Xq_train = pca.fit_transform(X_train_scaled)
Xq_test = pca.transform(X_test_scaled)

print(Xq_train.shape, Xq_test.shape)

def haar_random_circuit(x, n_qubits=2, depth=2, seed=None):
    if seed is not None:
        np.random.seed(seed)

    qc = QuantumCircuit(n_qubits)

    # Angle encoding
    for i in range(n_qubits):
        qc.ry(x[i], i)

    # Haar-random layers
    for _ in range(depth):
        for i in range(n_qubits):
            theta, phi, lam = np.random.uniform(0, 2*np.pi, 3)
            qc.u(theta, phi, lam, i)

        for i in range(n_qubits - 1):
            qc.cx(i, i + 1)

    return qc

def compute_haar_kernel(X1, X2, n_qubits=2, depth=2):
    K = np.zeros((len(X1), len(X2)))

    for i, x1 in enumerate(X1):
        psi1 = Statevector.from_instruction(
            haar_random_circuit(x1, n_qubits, depth, seed=i)
        )

        for j, x2 in enumerate(X2):
            psi2 = Statevector.from_instruction(
                haar_random_circuit(x2, n_qubits, depth, seed=j)
            )

            K[i, j] = state_fidelity(psi1, psi2)

    return K

Xq_train_small = Xq_train[:50]
y_train_small = y_train[:50]

Xq_test_small = Xq_test[:20]
y_test_small = y_test[:20]

K_train = compute_haar_kernel(Xq_train_small, Xq_train_small)
K_test = compute_haar_kernel(Xq_test_small, Xq_train_small)

svm = SVC(kernel="precomputed")
svm.fit(K_train, y_train_small)

y_pred = svm.predict(K_test)

print("Accuracy:", accuracy_score(y_test_small, y_pred))
print("F1 score:", f1_score(y_test_small, y_pred))

n_qubits = 3

pca = PCA(n_components=n_qubits, random_state=42)

Xq_train = pca.fit_transform(X_train_scaled)
Xq_test  = pca.transform(X_test_scaled)

print("Quantum feature shapes:", Xq_train.shape, Xq_test.shape)

def haar_random_circuit(x, n_qubits=3, depth=2, seed=None):
    if seed is not None:
        np.random.seed(seed)

    qc = QuantumCircuit(n_qubits)

    # Angle encoding
    for i in range(n_qubits):
        qc.ry(x[i], i)

    # Haar-random layers
    for _ in range(depth):
        for i in range(n_qubits):
            theta, phi, lam = np.random.uniform(0, 2*np.pi, 3)
            qc.u(theta, phi, lam, i)

        # Linear entanglement
        for i in range(n_qubits - 1):
            qc.cx(i, i + 1)

    return qc

def compute_haar_kernel(X1, X2, n_qubits=3, depth=2, seed=123):
    K = np.zeros((len(X1), len(X2)))

    for i, x1 in enumerate(X1):
        psi1 = Statevector.from_instruction(
            haar_random_circuit(x1, n_qubits, depth, seed=seed)
        )

        for j, x2 in enumerate(X2):
            psi2 = Statevector.from_instruction(
                haar_random_circuit(x2, n_qubits, depth, seed=seed)
            )

            K[i, j] = state_fidelity(psi1, psi2)

    return K

Xq_train_small = Xq_train[:50]
y_train_small  = y_train[:50]

Xq_test_small  = Xq_test[:20]
y_test_small   = y_test[:20]

K_train = compute_haar_kernel(Xq_train_small, Xq_train_small)
K_test  = compute_haar_kernel(Xq_test_small,  Xq_train_small)

svm = SVC(kernel="precomputed")
svm.fit(K_train, y_train_small)

y_pred = svm.predict(K_test)

print("Accuracy:", accuracy_score(y_test_small, y_pred))
print("F1 score:", f1_score(y_test_small, y_pred))

import pandas as pd

# Create comparison table
comparison_df = pd.DataFrame({
    "Qubits": [2, 3],
    "Accuracy": [0.55, 0.45],
    "F1_Score": [0.7096, 0.5217]
})

# Display table
comparison_df

import matplotlib.pyplot as plt
qubits = [2, 3]
accuracy = [0.55, 0.45]
f1_scores = [0.71, 0.52]

plt.figure(figsize=(6,4))
plt.plot(qubits, accuracy, marker='o', label='Accuracy')
plt.plot(qubits, f1_scores, marker='s', label='F1 score')

plt.xlabel("Number of Qubits")
plt.ylabel("Score")
plt.title("Haar-Random Quantum Kernel Performance vs Qubits")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.savefig("haar_performance_vs_qubits.png", dpi=300)
plt.show()

plt.figure(figsize=(6,4))
plt.hist(K_train.flatten(), bins=30, alpha=0.7)

plt.xlabel("Kernel Value")
plt.ylabel("Frequency")
plt.title("Distribution of Haar Quantum Kernel Values")
plt.grid(True)
plt.tight_layout()
plt.savefig("haar_kernel_distribution.png", dpi=300)
plt.show()

